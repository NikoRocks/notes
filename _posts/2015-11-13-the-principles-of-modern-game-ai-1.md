---
title: Принципы современного игрового ИИ. Первый урок
---

В данном уроке рассматриваются то,  как в интерактивных агентах выглядят потоки
информации и  управления, какие есть  стратегии обновления игровых  сущностей в
игровом цикле,  а также приводятся  некоторые подходы к  построению архитектуры
ИА.

## 1.1 Архитектура агента

Классическая схема вычислительного процесса интерактивного агента, пришедшая из
области робототехники, это связка "*ощущаю - думаю - действую*".

На  первом  этапе,  этапе  *ощущений*, агент  собирает,  как-то  преобразует  и
запоминает ту или иную информацию из внешнего мира с помощью специализированных
сенсоров.  На  этапе  *обдумывания* происходит  анализ  накопленной  информации
с  целью  определить,  какие   действия  необходимо  совершить  для  достижения
поставленных  целей.  И, собственно,  после  этого  происходит черёд  совершать
*действия*.

Не  смотря  на кажущуюся  простоту,  любой  из  этих  шагов может  быть  весьма
сложен: при принятии того или  иного решения может потребоваться дополнительная
информация  из окружающего  мира, и  необходимо будет  сделать ещё  один запрос
к  сенсорам;  при  планировании может  использоваться  механизм  предугадывания
результата действий, то  есть будет задействована подсистема,  отвечающая за их
исполнение.  Таким образом,  в отсутствие  архитектуры каждый  из этапов  будет
размазан по коду.

Первый подход к построению  архитектуры заключается в выделении *функциональных
слоёв*,  каждый из  которых отвечает  за тот  или иной  аспект работы  движка -
например, физику,  анимацию, поведение  и так далее.  Поток управления  в таком
случае  перестаёт быть  горизонтальным и  становится вертикальным:  каждый слой
строится поверх  другого. Внутри  каждого из  слоёв, впрочем,  логика поведения
остаётся схожей  - мы  анализируем внешние  данные для  генерации тех  или иных
действий.  С другой  стороны, не  каждый  из слоёв  непосредственно сам  меняет
состояние ИА  - для  этого может  потребоваться использовать  функционал других
слоёв.  Например, слой  навигации после  генерации оптимального  маршрута может
обратиться к слоям физики и анимации.

![](/images/the-principles-of-modern-game-ai/1/1-layers.jpg)

Такая архитектура даёт следующие преимущества:

- очевидная структура агента в коде
- упрощение внутренних перекрёстных зависимостей в коде
- и, как следствие,  упрощение поддержки, в том числе с  целью удаления - если,
например, в следующей игре, использующей  тот же движок, исчезнет необходимость
поддерживать тот или иной аспект

С целью  повысить эффективность вычислений  и модульность имеет  смысл выделить
код,  отвечающий за  взаимодействие  с игровым  движком,  в отдельные  системы:
систему физики, анимации и т. д., предоставляющих высокоуровневый интерфейс для
соответствующих компонентов;  в них  же могут шариться  общая для  всех агентов
информация и алгоритмы.

## 1.2 Поток информации

Можно выделить несколько  фаз работы интерактивного агента.  Первая и последняя
фаза обязательны,  но остальные  могут быть  присущи не  всем агентам  - когда,
например, не требуется чрезвычайно сложное, человекоподобное поведение.

*Извлечение* информации из игрового мира и преобразование её в структуры, более
подходящие для обработки внутри ИА.

*Обработка*  извлечённой информации:  преобразование и  объединение её  в более
сложные структуры для последующих фаз.

*Обдумывание* имеющейся  информации с  целью дополнения общей  картины фактами,
которые  можно   построить  на   основе  извлечённой  информации,   но  которые
отсутствуют  а  ней напрямую  -  например,  предположение о  текущем  положении
игрока.

*Принятие  решения*, исходя  из  целей существования  ИА  и результатов  работы
предыдущей  фазы.  На  этом  этапе могут  использоваться  алгоритмы  построения
оптимального пути, предположения  о том, какие реакции последуют в  ответ на те
или иные действия и так далее.

*Генерация* структур  данных, пригодных для конвертации  в примитивные операции
игрового движка, на основе принятых решений.

*Конвертация* принятых решений обратно  в низкоуровневые понятия игрового движка
(перемещение в пространстве, отыгрывание анимации и так далее).

Существует два  подхода к  тому, как будет  оповещаться интерактивный  агент об
изменениях окружающего  мира. Первый  подход - *поллинг*,  когда агент  сам, на
периодической основе, опрашивает  мир. Такой подход хорошо  применять в случае,
если мир обновляется  довольно части - иначе оверхэд на  опрос информации будет
неоправданным. Альтернатива ему,  в случае, когда изменения  происходят редко -
это *пушинг*, при котором ИА  подписывается на некоторые события игрового мира,
и уведомляется о их наступлении.

![](/images/the-principles-of-modern-game-ai/1/2-polling.jpg)

Разумеется,  можно   применять  гибридный   вариант,  когда   некоторые  данные
окружающего мира  изменяются часто  и агент  обновляет их  самостоятельно путём
опроса,  а для  других, менее  часто обновляемых  данных, используется  система
подписки.

## 1.3 Поток управления

В типичном  случае на  каждом витке игрового  цикла для каждого  ИА у  нас есть
несколько задач, которые необходимо выполнить,  причём некоторые из них зависят
одна от другой.

Существует   два  решения   этой   задачи.   Первая,  *обновление   сущностей*,
фокусируется на обновлении отдельных сущностей последовательно. На каждом витке
игрового  цикла  происходит  итерация  по всем  сущностям,  которые  необходимо
обновить, и для каждой выполняются необходимые ей действия. Данный подход прост
в реализации  и понимании процесса  исполнения и довольно часто  применяется. С
другой  стороны, он  не  самый оптимальный  с  точки зрения  производительности
и  может  быть чреват  ошибками  вследствие  серьёзной зависимости  от  порядка
исполнения задач.

Второй подход,  *обновление слоёв*, фокусируется на  последовательной обработке
системных слоёв, таких  как слой анимации, слой  физики и т. д.,  для каждой из
сущностей. То есть  перед началом обработки очередного слоя  обработка в рамках
предыдущего для каждой  сущности уже завершилась. Порой  обработку каждого слоя
даже разделяют на несколько шагов, для большей гибкости. Плюсы такого подхода -
оптимальное использование  доступных ресурсов  и меньшая  вероятность совершить
простые ошибки, но при  этом его реализация требует много времени  и опыта, а в
некоторых случаях такой подход может даже мешать.

![](/images/the-principles-of-modern-game-ai/1/3-updating-layers.jpg)

Ради оптимизации  задачи агентов  имеет смысл объединить  в пакеты  по принципу
независимости  друг  от  друга,  то   есть  в  рамках  одного  пакета  возможно
параллельное исполнение несколько задач.

Итак, чаще всего имеет смысл начинать  с обновления сущностей и дальше, по мере
необходимости, переходить на обновление слоёв в те или иных аспектах.

Для решения задачи обновления сущностей выделяют несколько стратегий:

1. *Брутфорс*.  Тут все просто -  каждый виток цикла происходит  обработка всех
сущностей. Этот подход простой, ясный и при этом визуально привлекательный - на
каждом витке мы уверены, что все сущности обновили своё представление. С другой
стороны, его  можно считать медленным  и зря тратящим  ресурсы - не  все агенты
могут требовать обновления на данном витке.

2. *На  основе событий*.   Те или  иные сущности  проходят процесс  обновления в
данном  витке  только в  случае,  если  произошло определённое  событие.   Таким
образом, за счёт  того, что на каждом витке обрабатываются  только нуждающиеся в
обработке сущности, данный  подход является довольно быстрым,  все ещё визуально
привлекательным и при этом - элегантным. Но он чреват вычислительными спайками -
в случае,  когда на очередном витке  произошло слишком много событий,  это может
привести к проседанию производительности.

3.  [*Раунд робин*][round-robin].  При  этом подходе  все  сущности делятся  на
несколько групп,  и на  каждом витке происходит  обработка сущностей  только из
одной группы, по очереди. Данный подход менее визуально отзывчивый, но при этом
достаточно предсказуемый с точки зрения вычислений.

4.  *На   основе  очередей*.  Данный   подход  комбинирует  два   предыдущих  с
целью  оставаться   визуально  отзывчивым   и  при  этом   избежать  проседания
производительности. События,  указывающие на  необходимость обновления  той или
иной сущности, ставятся в очередь  и откладываются до следующего игрового витка
при достижении определённого лимита ресурсов. Данный подход менее предсказуемый
и более сложный в реализации.

5.  *Приоритизация*,  который может  комбинироваться  с  другими стратегиями  и
больше подходит  для игр с большим  открытым миром. При этом  подходе чем ближе
сущности к  игроку, тем больший приоритет  на обновление они имеют;  сущности с
низким приоритетом могут  вставать в очередь на обновление  либо не обновляться
вовсе.

[Предыдущий урок]({% post_url 2015-10-28-the-principles-of-modern-game-ai-0 %})

[Следующий урок]({% post_url 2015-12-19-the-principles-of-modern-game-ai-2 %})


[round-robin]: https://ru.wikipedia.org/wiki/Round-robin_(алгоритм)
