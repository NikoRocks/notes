---
title: Принципы современного игрового ИИ. Третий урок
---

TBD

## 3.1 Представления

Для того, чтобы научить машину думать и принимать решения, ей необходимо
каким-то образом хранить и обрабатывать ту или иную информацию о внешнем мире.
Вопрос представления информации является одним из самых важных при разработке
интерактивных агентов, да и вообще любой системы, потому что компьютеры всегда
не оперируют ничем, кроме информации, на любом из уровней.

По сравнению с классическим академическим ИИ, где оперировали в основном
символами и логикой первого порядка для представления информации о мире, в
робототехнике акцент смещен в сторону реальных (непрерывных)
значений, посколько окружающий мир недискретен.
Компьютерные игры находятся где-то посредине между двумя этими категориями,
активно используя и комбинирую подходы из обоих областей.

Для построения моделей реального мира используют те или иные структуры данных,
которые комбинирются из скалярных значений того или иного типа.
Для представления информации придумано огромное количество структур данных, в
том числе специфичных и для ИИ.

Обычно принято делить типы данных в зависимости от объема хранимых в них
значений, например, char, int16, float32 и так далее. Но при разработке интерактивных
агентов чаще принята другая классификация.

Для целей символьного представления данных типы делятся на следующие.

Это, во-первых, *символы* - уникальные идентификаторы
какого-то концепта внутри игры о котором, как предполагается, может размышлять
интерактивный агент. Примероми могут служить: `mana`, `health`, `door-B03`,
`DRIVER_07` и так далее.

Следующие на очереди - *булевы значения*, которые, помимо привычных значений
`истина` и `ложь`, в приминении к ИИ могут изметь значение `неизвестно` в
случаях, когда о каком-то факте нельзя сказать, истиннен он или ложен. Служат
эти типы значений, как нетрудно догадаться, для запоминания агентами
значений каких-то внутриигровых фактов.

И, наконец, *целые числа*, которые можно считать частным случаем типа "символ".
Применяются эти значения практически повсеместно - в счетчиках, рангах и так
далее, перечислять все варианты приминения просто бесмысленно.

Для представления численных данных используются следующая классификация.
Практически все типы являются числами с плавающей точкой, потому порой
возникает путаница с определением того, к какому типу относится то или иное
значение.

*Вспомогательные значения (utility values)* используются для хранения информации о степени
предпочтительности чего-либо по сравнению с другими вариантами в списке.
Например, число, характеризующее пригодность того или иного местоположения для
того, чтобы спрятаться от игрока, является значением вспомогательного типа;
соответственно, интерактивный агент хранит эти значения для того, чтобы позже
сделать выбор о том, где укрыться.

![](/images/the-principles-of-modern-game-ai/3/1-utility-values.jpg)

Для целей нечеткой логики используются *нечеткие символы (fuzzy symbols)*,
которые описывают степень истинности некоторого предположения - например, того,
успел ли увидеть игрок агента. Эти значения похожи на показатели вероятности,
мы можем увеличивать или уменьшать их значения на основе каких-то фактов.

![](/images/the-principles-of-modern-game-ai/3/2-fuzzy-symbols.jpg)

Значения, описывающие степень *вероятности* наступления того или иного события,
и заключены они между нулем и единицей.
В отличии от нечетких символов данные значения используются для описания
ситуаций, наступления которых ожидается в будущем; для того, чтобы пытаться
предсказать, какое поведение будет наиболее вероятным при тех или иных
событиях; то есть, спекуляции о возможных ситуациях в будущем, для построения
дерева принятия решений.
В качестве примера можно рассмотреть как будет покидать укрытие интерактинвый
агент: выбрыгнет ли он на врага если тот достаточно близко или же убежит в
другую сторону.
То есть, в отличии от нечетких символов, событие - покинуть укрытие -
обязательно наступит в будущем, но каким способом оно будет достигнуто, зависит
от степени вероятности.

![](/images/the-principles-of-modern-game-ai/3/3-probabilities.jpg)

Из всех перечисленных выше простых типов данных строятся более сложные,
составные типы, называемые структурами данных. Сейчас мы рассмотрим наиболее
популярные из них.

На первом месте, разумеется, идут *списки* - одно- или двусвязные. Эта 
структура данных характеризуется простотой реализации, гибкостью при изменении
размеров (?) и применяется для хранения часто меняющихся динамичных коллекций различных элементов,
имеет низкую стоимость вставки, но пробегаться по всем элементам является более
дорогой операцией, потому не рекомендуется использовать в случаях, когда это
требуется часто.

*Словари*, структура данных, индексирующая информацию по ассоциированному с ней
ключу, используются для динамических коллекций ради высокой скорости
получения связанного объекта по ключу, так как поиск при этом не используется,
потому как используется хэширование.

Статические *массивы*, имея свойства, характерные спискам, используются для
хранения данных одного типа, которые часто требуется обходить в цикле. Они
имеют большую скорость для этой задачи потому как данные размещены в памяти
неприрывно, но в качестве минусов есть необходимость знать размер массива до
его создания и невозможность этот размер менять. *Многомерные массивы* обладают
теми же характеристиками, так как строятся на основе обычных массивов, и
используются чаще всего для хранения информаии о данных об многомерном игровом
пространстве.

*Графы*, используемые для описания отношений между своими элементами, могут
быть как динамически расширяемыми, так и статическими, в зависимости от того,
на основе чего они реализованы - на основе списков или же массивов. Частным
случаем графа является *дерево*, обладает теми же приемуществами, что и граф,
но, так как не предполагает циклов, используется для хранения информации об
иерархических данных - описания родственных отношений, декомпозиции объектов и
так далее.

## 3.2 "Школьные доски" и "рабочая память"

В данном разделе идет обсуждение способов организации архитектуры
интерактивного агента. Рассматриваются такие компоненты, как blackboard, или,
по-русски, школьная доска, и working memory, или рабочая память.

Школьная доска - это перевод термина blackboard
(https://en.wikipedia.org/wiki/Blackboard_(design_pattern),
https://en.wikipedia.org/wiki/Blackboard_system). Если смотреть на архитектуру
интерактивного агента в целом, может показаться, что концептуально "рабочая
память" и "школьная доска" абсолютно идентичны. Тем не менее, между ними
существуют некоторые различия.

![](/images/the-principles-of-modern-game-ai/3/4-arch-overview.jpg)

Принцип "школьной доски" весьма прост. У нас имеется несколько компонентов,
каждый из которых имеет доступ к какой-то структуре, которая называется
blackboard. Некоторые компоненты только читают оттуда, некоторые - пишут, а
некоторые делают и то, и другое. Предпологается, что "школьная доска"
разделяются между экземплярами компонентов только одного интерактивного агента,
то есть разные агенты имеют для своих нужд разные "доски".

![](/images/the-principles-of-modern-game-ai/3/5-blackboard-arch.jpg)

Для реализации "школьной доски" обычно используются структуры данных, подобные
словарям, то есть с обращением к данным по имени, которые, в зависимости от нужд, могут быть как динамическими
(собственно, dict в Python) или статическими (struc из C). В качестве значений
могут храниться любые типы данных - как скалярные, так и составные.

Каждая информационная система, и интерактивный агент не являются исключением,
требует взаимодействия модулей, из которых она состоит, обмена данными между
ними, но при этом должна стремиться к уменьшению сцепленности
(https://ru.wikipedia.org/wiki/Зацепление_(программирование)) между модулями,
чтобы разработка и поддержка системы не превратилась в ад.
Blackboard отчасти решает эту задачу, потому как предоставляет механизм, в
котором n-to-n связи между различными компонентами заменяются на n связей к
центральному звену, собственно, и являющемся школьной доской.

![](/images/the-principles-of-modern-game-ai/3/6-n-to-n.jpg)

Для тех, кто знаком с паттернами проектирования "одиночка" (singleton), можно
сказать, что blackboard является неким его аналогом, но не глобальным в рамках
всей системы, а только для компонентов каждого интерактивного агента.

Обычно "школьные доски" используют для того, чтобы шарить между компонентами
конфигурационные переменные, переменные рантайма и использовать в качестве
механизма обмена сообщениями или уведомления/подписки на некоторые события.

Blackboard является общим для компонентов с различных слоев, или уровней,
информационного агента. Например, компонент с уровень обнаружения столкновений может
поместить информации о препятствии на доску, а более низкоуровневый механизм
анимаций узнать об этой информации и отреагировать должным образом.

![](/images/the-principles-of-modern-game-ai/3/7-different-layers.jpg)

Итак, приемуществами "школьных досок" являются:

1. Легкая возможность поверхностного обзора состояния агента, то есть чем агент
   предназначен заниматься

2. Простой механизм добавления неких глобальных переменных уровня агента

3. Архитектура становится чуточку более модульной за счет разрыва n-to-n связей

При этом к недостаткам относятся:

1. Трудность масштабирования и возможностей параллелизации обработки за счет
   того, что доска является разделяемым ресурсом и нужно следить за
   очередностью доступа к ней

2. Централизация всего не всегда является хорошим решением - например, в
   случае, когда различных компонентов слишком много, в плане модульности
   подход со "школьной доской" не сильно лучше n-to-n связей

3. Как дополнение ко второму пункту, с увеличением количества использующих
   доску компонентов становится сложно контролировать то, кто, когда и каким
   образом использует те или иные значение, то есть теряется контроль над
   состоянием системы

Тем не менее, не смотря на недостатки, "школьные доски" являются
удовлетворительным архитектурным решением для обмена статически типизированными
данными между компонентами.

Термин "рабочая память" пришел из психологии, где так называется та
кратковаременная память, что отвечает за хранение информации на период ее
обработки. Исследования показывают, что в среднем человек может хранить не
более семи фактов в рабочей памяти, но для нужд интерактивных агентов мы
вольны использовать столько слотов, сколько необходимо.

Концепция рабочей памяти тесно связано с так называемой "моделью мира", то есть
представлением конкретного агента об окружающем мира, ментальной моделью мира,
которая не идентична реальному положению вещей. Подход с моделью мира
замечателен тем, что он предоставляет возможность манипулировать "сознанием"
интерактивного агента и, соотвественно, его поведением довольно простым
способом, создавая весьма человекоподобное поведение. Например, без
использоватния модели мира солдат в каком-нибудь шутере наверняка знает о том,
где находится пользователь, и его поведение теряет реалистичность. Если же мы
внедрим прослойку в виде ментальной модели между реальным миром и "сознанием"
агента, мы можем, добавив в эту прослойку "факт" (который может быть и ложным,
но в котором агент будет абсолютно уверен), что игрок находится за дверью,
это заставит солдата подойти к двери с осторожностью или же выпустить по ней
очередь.

![](/images/the-principles-of-modern-game-ai/3/8-working-memory.jpg)

Итак, механизм рабочей памяти и модели мира, отдельной от реальной, обладает
следующими преимуществами:

- возможность простой подмены фактов о мире для каждого конкретного агента, что
  заставит агентов "верить" в их истинность

- реализация более высокоуровнего, сложного и реалистичного поведения

- нет необходиммости использовать специальные алгоритмы для реализации
  реалистичного поведения

- как и в случае с blackboard, через механизм рабочей памяти могут
  взаимодействовать несколько компонентов

Так как реализация рабочей памяти похожа на реализацию "школьной доски", она
обладает и схожими проблемами. Есть несколько способов реализации данных
механизмов, которые предназначены для борьбы с возникающими сложностями.

При разработке архитектуры этих мехонизмом необходимо принять решения,
согласившись на трейд-оффы, по следующим пунктам.

1. Централизация/распределенность

2. Статичность/динамичность

3. Время жизни объектов

4. Поток управления - синхронный/асинхронный

Прежде
всего, для борьбы со сложностью масштабирования, в случае, когда есть
количество компонентов или записей на доске очень большое, имеет смысл выделить
несколько различных "областей" внутри общей доски, или "поддосок", значения в
которых будут сгруппированы по тому, какими компонентами они совместно
используются.

![](/images/the-principles-of-modern-game-ai/3/9-subboards.jpg)

По поводу статичности либо динамичности механизма можно сказать, что под
статичностью тут, с одной стороны, имеется ввиду разрешение только определенных
ключей на доске, а с другой, ограничение на хранимые значения, например,
разрешать хранить значения только определенного формата. При работе в больших
командах имеет смысл делать упор на большую строгость и статичность; с другой
стороны, динамичность увеличивает гибкость системы.

Контроль за хранимыми на доске значениями, то есть их удаление в нужное время,
является важным вопросом, поскольку некорректное поведение интерактивного
агента по статистике чаще всего связано с тем, что он оперирует устаревшими
фактами - например, объект уже удалет из мира, но ссылка на доске на него все
ещё присутствует. В качестве решений существуют использование времени жизни
у каждого значения, периодическая их очистка или же использование своебразного
сборщика мусора - например, с подсчетом ссылок.

![](/images/the-principles-of-modern-game-ai/3/10-lifetime.jpg)

Вопрос контроля потока управления тесно связан с контролем за временем жизни
значений. Преимущества и недостатки прямого и асинхронного контролей были
описаны в предыдущем уроке. Вкратце, можно сказать, что при использовании
синхронного подхода на каждом этапе вычисления значения, добавленные на
предыдущем шаге, остаются доступными для обработки,
а в случае с асинхронным подходом необходим некий механизм
оповещений о добавлении/изменении значения (observer/callback).

При разработке и отладке системы со столь слабо связанными компонентами хорошим подспорьем
является наличие хорошией системы логирования. Идеально, если каждое изменение
значения на доске будет ассоциировано с информацией о том, откуда оно пришла, в
какое время (timestamp), а в случае, если ожидалось, что значение присутствует
на доске, но оно отсутствовало, информация о том, кто его запрашивал. Данную
систему несложно добавить, используя, например, механизм метапрограммирования.
