---
title: Принципы современного игрового ИИ. Третий урок
---

TBD

## 3.1 Представления

Для того, чтобы научить машину думать и принимать решения, ей необходимо
каким-то образом хранить и обрабатывать ту или иную информацию о внешнем мире.
Вопрос представления информации является одним из самых важных при разработке
интерактивных агентов, да и вообще любой системы, потому что компьютеры всегда
не оперируют ничем, кроме информации, на любом из уровней.

По сравнению с классическим академическим ИИ, где оперировали в основном
символами и логикой первого порядка для представления информации о мире, в
робототехнике акцент смещен в сторону реальных (непрерывных)
значений, посколько окружающий мир недискретен.
Компьютерные игры находятся где-то посредине между двумя этими категориями,
активно используя и комбинирую подходы из обоих областей.

Для построения моделей реального мира используют те или иные структуры данных,
которые комбинирются из скалярных значений того или иного типа.
Для представления информации придумано огромное количество структур данных, в
том числе специфичных и для ИИ.

Обычно принято делить типы данных в зависимости от объема хранимых в них
значений, например, char, int16, float32 и так далее. Но при разработке интерактивных
агентов чаще принята другая классификация.

Для целей символьного представления данных типы делятся на следующие.

Это, во-первых, *символы* - уникальные идентификаторы
какого-то концепта внутри игры о котором, как предполагается, может размышлять
интерактивный агент. Примероми могут служить: `mana`, `health`, `door-B03`,
`DRIVER_07` и так далее.

Следующие на очереди - *булевы значения*, которые, помимо привычных значений
`истина` и `ложь`, в приминении к ИИ могут изметь значение `неизвестно` в
случаях, когда о каком-то факте нельзя сказать, истиннен он или ложен. Служат
эти типы значений, как нетрудно догадаться, для запоминания агентами
значений каких-то внутриигровых фактов.

И, наконец, *целые числа*, которые можно считать частным случаем типа "символ".
Применяются эти значения практически повсеместно - в счетчиках, рангах и так
далее, перечислять все варианты приминения просто бесмысленно.

Для представления численных данных используются следующая классификация.
Практически все типы являются числами с плавающей точкой, потому порой
возникает путаница с определением того, к какому типу относится то или иное
значение.

*Вспомогательные значения (utility values)* используются для хранения информации о степени
предпочтительности чего-либо по сравнению с другими вариантами в списке.
Например, число, характеризующее пригодность того или иного местоположения для
того, чтобы спрятаться от игрока, является значением вспомогательного типа;
соответственно, интерактивный агент хранит эти значения для того, чтобы позже
сделать выбор о том, где укрыться.

![](/images/the-principles-of-modern-game-ai/3/1-utility-values.jpg)

Для целей нечеткой логики используются *нечеткие символы (fuzzy symbols)*,
которые описывают степень истинности некоторого предположения - например, того,
успел ли увидеть игрок агента. Эти значения похожи на показатели вероятности,
мы можем увеличивать или уменьшать их значения на основе каких-то фактов.

![](/images/the-principles-of-modern-game-ai/3/2-fuzzy-symbols.jpg)

Значения, описывающие степень *вероятности* наступления того или иного события,
и заключены они между нулем и единицей.
В отличии от нечетких символов данные значения используются для описания
ситуаций, наступления которых ожидается в будущем; для того, чтобы пытаться
предсказать, какое поведение будет наиболее вероятным при тех или иных
событиях; то есть, спекуляции о возможных ситуациях в будущем, для построения
дерева принятия решений.
В качестве примера можно рассмотреть как будет покидать укрытие интерактинвый
агент: выбрыгнет ли он на врага если тот достаточно близко или же убежит в
другую сторону.
То есть, в отличии от нечетких символов, событие - покинуть укрытие -
обязательно наступит в будущем, но каким способом оно будет достигнуто, зависит
от степени вероятности.

![](/images/the-principles-of-modern-game-ai/3/3-probabilities.jpg)

Из всех перечисленных выше простых типов данных строятся более сложные,
составные типы, называемые структурами данных. Сейчас мы рассмотрим наиболее
популярные из них.

На первом месте, разумеется, идут *списки* - одно- или двусвязные. Эта 
структура данных характеризуется простотой реализации, гибкостью при изменении
размеров (?) и применяется для хранения часто меняющихся динамичных коллекций различных элементов,
имеет низкую стоимость вставки, но пробегаться по всем элементам является более
дорогой операцией, потому не рекомендуется использовать в случаях, когда это
требуется часто.

*Словари*, структура данных, индексирующая информацию по ассоциированному с ней
ключу, используются для динамических коллекций ради высокой скорости
получения связанного объекта по ключу, так как поиск при этом не используется,
потому как используется хэширование.

Статические *массивы*, имея свойства, характерные спискам, используются для
хранения данных одного типа, которые часто требуется обходить в цикле. Они
имеют большую скорость для этой задачи потому как данные размещены в памяти
неприрывно, но в качестве минусов есть необходимость знать размер массива до
его создания и невозможность этот размер менять. *Многомерные массивы* обладают
теми же характеристиками, так как строятся на основе обычных массивов, и
используются чаще всего для хранения информаии о данных об многомерном игровом
пространстве.

*Графы*, используемые для описания отношений между своими элементами, могут
быть как динамически расширяемыми, так и статическими, в зависимости от того,
на основе чего они реализованы - на основе списков или же массивов. Частным
случаем графа является *дерево*, обладает теми же приемуществами, что и граф,
но, так как не предполагает циклов, используется для хранения информации об
иерархических данных - описания родственных отношений, декомпозиции объектов и
так далее.

## 3.2 "Школьные доски" и "рабочая память"

В данном разделе идет обсуждение способов организации архитектуры
интерактивного агента. Рассматриваются такие компоненты, как blackboard, или,
по-русски, школьная доска, и working memory, или рабочая память.

Школьная доска - это перевод термина blackboard
(https://en.wikipedia.org/wiki/Blackboard_(design_pattern),
https://en.wikipedia.org/wiki/Blackboard_system). Если смотреть на архитектуру
интерактивного агента в целом, может показаться, что концептуально "рабочая
память" и "школьная доска" абсолютно идентичны. Тем не менее, между ними
существуют некоторые различия.

![](/images/the-principles-of-modern-game-ai/3/4-arch-overview.jpg)

Принцип "школьной доски" весьма прост. У нас имеется несколько компонентов,
каждый из которых имеет доступ к какой-то структуре, которая называется
blackboard. Некоторые компоненты только читают оттуда, некоторые - пишут, а
некоторые делают и то, и другое. Предпологается, что "школьная доска"
разделяются между экземплярами компонентов только одного интерактивного агента,
то есть разные агенты имеют для своих нужд разные "доски".

![](/images/the-principles-of-modern-game-ai/3/5-blackboard-arch.jpg)

Для реализации "школьной доски" обычно используются структуры данных, подобные
словарям, то есть с обращением к данным по имени, которые, в зависимости от нужд, могут быть как динамическими
(собственно, dict в Python) или статическими (struc из C). В качестве значений
могут храниться любые типы данных - как скалярные, так и составные.

Каждая информационная система, и интерактивный агент не являются исключением,
требует взаимодействия модулей, из которых она состоит, обмена данными между
ними, но при этом должна стремиться к уменьшению сцепленности
(https://ru.wikipedia.org/wiki/Зацепление_(программирование)) между модулями,
чтобы разработка и поддержка системы не превратилась в ад.
Blackboard отчасти решает эту задачу, потому как предоставляет механизм, в
котором n-to-n связи между различными компонентами заменяются на n связей к
центральному звену, собственно, и являющемся школьной доской.

![](/images/the-principles-of-modern-game-ai/3/6-n-to-n.jpg)

Для тех, кто знаком с паттернами проектирования "одиночка" (singleton), можно
сказать, что blackboard является неким его аналогом, но не глобальным в рамках
всей системы, а только для компонентов каждого интерактивного агента.

Обычно "школьные доски" используют для того, чтобы шарить между компонентами
конфигурационные переменные, переменные рантайма и использовать в качестве
механизма обмена сообщениями или уведомления/подписки на некоторые события.

Blackboard является общим для компонентов с различных слоев, или уровней,
информационного агента. Например, компонент с уровень обнаружения столкновений может
поместить информации о препятствии на доску, а более низкоуровневый механизм
анимаций узнать об этой информации и отреагировать должным образом.

![](/images/the-principles-of-modern-game-ai/3/7-different-layers.jpg)

Итак, приемуществами "школьных досок" являются:

1. Легкая возможность поверхностного обзора состояния агента, то есть чем агент
   предназначен заниматься

2. Простой механизм добавления неких глобальных переменных уровня агента

3. Архитектура становится чуточку более модульной за счет разрыва n-to-n связей

При этом к недостаткам относятся:

1. Трудность масштабирования и возможностей параллелизации обработки за счет
   того, что доска является разделяемым ресурсом и нужно следить за
   очередностью доступа к ней

2. Централизация всего не всегда является хорошим решением - например, в
   случае, когда различных компонентов слишком много, в плане модульности
   подход со "школьной доской" не сильно лучше n-to-n связей

3. Как дополнение ко второму пункту, с увеличением количества использующих
   доску компонентов становится сложно контролировать то, кто, когда и каким
   образом использует те или иные значение, то есть теряется контроль над
   состоянием системы

Тем не менее, не смотря на недостатки, "школьные доски" являются
удовлетворительным архитектурным решением для обмена статически типизированными
данными между компонентами.

Термин "рабочая память" пришел из психологии, где так называется та
кратковаременная память, что отвечает за хранение информации на период ее
обработки. Исследования показывают, что в среднем человек может хранить не
более семи фактов в рабочей памяти, но для нужд интерактивных агентов мы
вольны использовать столько слотов, сколько необходимо.

Концепция рабочей памяти тесно связано с так называемой "моделью мира", то есть
представлением конкретного агента об окружающем мира, ментальной моделью мира,
которая не идентична реальному положению вещей. Подход с моделью мира
замечателен тем, что он предоставляет возможность манипулировать "сознанием"
интерактивного агента и, соотвественно, его поведением довольно простым
способом, создавая весьма человекоподобное поведение. Например, без
использоватния модели мира солдат в каком-нибудь шутере наверняка знает о том,
где находится пользователь, и его поведение теряет реалистичность. Если же мы
внедрим прослойку в виде ментальной модели между реальным миром и "сознанием"
агента, мы можем, добавив в эту прослойку "факт" (который может быть и ложным,
но в котором агент будет абсолютно уверен), что игрок находится за дверью,
это заставит солдата подойти к двери с осторожностью или же выпустить по ней
очередь.

![](/images/the-principles-of-modern-game-ai/3/8-working-memory.jpg)

Итак, механизм рабочей памяти и модели мира, отдельной от реальной, обладает
следующими преимуществами:

- возможность простой подмены фактов о мире для каждого конкретного агента, что
  заставит агентов "верить" в их истинность

- реализация более высокоуровнего, сложного и реалистичного поведения

- нет необходиммости использовать специальные алгоритмы для реализации
  реалистичного поведения

- как и в случае с blackboard, через механизм рабочей памяти могут
  взаимодействовать несколько компонентов

Так как реализация рабочей памяти похожа на реализацию "школьной доски", она
обладает и схожими проблемами. Есть несколько способов реализации данных
механизмов, которые предназначены для борьбы с возникающими сложностями.

При разработке архитектуры этих мехонизмом необходимо принять решения,
согласившись на трейд-оффы, по следующим пунктам.

1. Централизация/распределенность

2. Статичность/динамичность

3. Время жизни объектов

4. Поток управления - синхронный/асинхронный

Прежде
всего, для борьбы со сложностью масштабирования, в случае, когда есть
количество компонентов или записей на доске очень большое, имеет смысл выделить
несколько различных "областей" внутри общей доски, или "поддосок", значения в
которых будут сгруппированы по тому, какими компонентами они совместно
используются.

![](/images/the-principles-of-modern-game-ai/3/9-subboards.jpg)

По поводу статичности либо динамичности механизма можно сказать, что под
статичностью тут, с одной стороны, имеется ввиду разрешение только определенных
ключей на доске, а с другой, ограничение на хранимые значения, например,
разрешать хранить значения только определенного формата. При работе в больших
командах имеет смысл делать упор на большую строгость и статичность; с другой
стороны, динамичность увеличивает гибкость системы.

Контроль за хранимыми на доске значениями, то есть их удаление в нужное время,
является важным вопросом, поскольку некорректное поведение интерактивного
агента по статистике чаще всего связано с тем, что он оперирует устаревшими
фактами - например, объект уже удалет из мира, но ссылка на доске на него все
ещё присутствует. В качестве решений существуют использование времени жизни
у каждого значения, периодическая их очистка или же использование своебразного
сборщика мусора - например, с подсчетом ссылок.

![](/images/the-principles-of-modern-game-ai/3/10-lifetime.jpg)

Вопрос контроля потока управления тесно связан с контролем за временем жизни
значений. Преимущества и недостатки прямого и асинхронного контролей были
описаны в предыдущем уроке. Вкратце, можно сказать, что при использовании
синхронного подхода на каждом этапе вычисления значения, добавленные на
предыдущем шаге, остаются доступными для обработки,
а в случае с асинхронным подходом необходим некий механизм
оповещений о добавлении/изменении значения (observer/callback).

При разработке и отладке системы со столь слабо связанными компонентами хорошим подспорьем
является наличие хорошией системы логирования. Идеально, если каждое изменение
значения на доске будет ассоциировано с информацией о том, откуда оно пришла, в
какое время (timestamp), а в случае, если ожидалось, что значение присутствует
на доске, но оно отсутствовало, информация о том, кто его запрашивал. Данную
систему несложно добавить, используя, например, механизм метапрограммирования.

# 3.3 Пространственная геометрия

Главными проблемами, возникающими при работе над пространством в компьютерных
играх, является то, что реальный мир, эмуляция которого происходит в игре,
обладает характеристиками, сложными для реализации их в игре. Преждве всего к
этому относится: непрерывность реального мира, в том время как компьютеры
способны оперировать только дискретными величинами; высокая степень детализации
(множество предметов, узоров и т. д.), каждый их которых необходимо учитывать;
разный ландшафт (в то время как в пустынном ландшафте высота изменяется плавно,
в горном возможны очень резкие переходы).

![](/images/the-principles-of-modern-game-ai/3/11-spatial-hell.jpg)

Как следствие этого, мы можем строить только некую аппроксимацию реального
мира, его приближение. Необходимо балансировать между точностью при описании
виртуального мира и производительностью.

Еще одной сложностью является то, что пространство должно учитываться во всех
аспектах работы интерактивного агента, будь то физика, в том числе система
обнаружения столкновений, анимация, навигация, принятие решений. Поэтому
необходимо уделять особое внимание тому, как различные компоненты
взаимодействуют с пространственной подсистемой, чтобы различия в трактовке
данных не приводили к трудноуловимым багам.

Вне зависимости от выбранных структур данных, существует несколько подходов к
работе с пространственной информации об уровне. Первый их них - препроцессинг,
когда "сырая" информация о структуре уровня, полученная от гейм-дизайнера,
преобразуется в более подходящие структуры данных, которые в момент рантайма
просто читаются и не изменяются. Другой подход - получать информацию о
структуре уровня в момент работы игры: медленней, но для высокодинамичных игр
иной подход найти сложно. Комбинированный вариант, своего рода баланс между
динамичностью и производительностью - это сделать возможность в рантайме
расширять статические структуры, генерируемые заранее.

![](/images/the-principles-of-modern-game-ai/3/12-spatial-preprocessing.jpg)

Вопрос о том, какую структуру данных выбрать для представления той или иной
пространственной информации делится на две части: на выбор примитивов,
описывающих информацию, и контейнеров, в которых они будут содержаться. Не
исключено, что ту же информацию ради целей производительности будет необходимо
предоставить в другом виде - потому что потребители у нее будет другие. Это не
возбраняется и является вполне естественным - в таком сложном вопросе вполне
удачным решением является создания какой-либо кастомной структуры данных на
основе примитивов.

Итак, основными примитивами, которые описывают одну дискретную область
пространства, являются:

- Точки, круги, сферы. Представлены они должны могут быть двумя или тремя
  параметрами. Круг или сфера получаются добавлением еще одного параметра,
  описывающего радиус. К преимуществам данного примитива можно отнести простоту
  реализации и вместе с тем ее гибкость, а также неплохое покрытие
  пространства: в случае проблем с покрытием всегда можно добавить новых точек
  или сфер, уменьшив радиус у остальных.

- Ячейки и прямоугольники. Представляются, опять же, двумя или тремя точками в
  зависимости от того, скольки мерное пространство представлено в игре, а также
  параметром, описывающим размер (в каждом направлении, если речь идет о
  прямоугольники). Главным приемуществом является отличное покрытие
  пространство, посколько ячейки вплотную прилегают друг к другу.

- Полигоны: трех- и четырехугольники. Представляются в машине вершинами, каждая
  из которых представлена тремя точками, а также ребрами (a, b), описывающими
  связи между каждый из точек. Они весьма часто используются по причине их
  эффективного покрытия пространства: можно покрыть любую поверхность
  комбинацией полигонов, используя тот или иной размер в случае необходимости
  повысить детализацию.

![](/images/the-principles-of-modern-game-ai/3/13-poly.jpg)


Контейнеры, предназначенные для хранения примитивов - это классические
структуры данных, которые в случае необходимости можно расширить. Используются
в зависимости от того, какая задача решается с их помощью. Прежде всего
сюда относятся:

Массивы и списки. Хотя списки используется чуть чаще, чем никогда по причине
того, что для решаемых задач, где часто требуется доступ ко всем элементам
сразу, а не их последовательный обход, лучше подходят массиы.

![](/images/the-principles-of-modern-game-ai/3/14-spatial-array.jpg)

Применяются они
тогда, когда требуется хранить набор каких-то элементов, относящихся к той
или иной области пространства: например, точек, в которых можно сделать
укрытие.

![](/images/the-principles-of-modern-game-ai/3/15-cover-locations.jpg)

Графы. Используются, когда необходимо описать то, как различные элементы
между собой связаны, то есть хранят помимо самих элементов связи между ними.
К примеру, в них можно хранить навигационные данные или данные о видимости
одних зон из других.

![](/images/the-principles-of-modern-game-ai/3/16-spatial-graph.jpg)

Сетка используется, когда необходимо разделить весь мир на равные участки.
Так как сетка является матрицей, ими можно манипулировать очень эффективно
используя, например, GPU. Применяется, когда необходимо описать, какое
влияние оказывается на окружающий мир каким-либо игровым объектом; объект
чаще всего находится в центре этой сетки.

![](/images/the-principles-of-modern-game-ai/3/17-spatial-grid.jpg)

Деревья используются для иерархичного разбиения пространства. Могут
применятся во многих случаях за счет быстрого доступа к любому элементу
(https://en.wikipedia.org/wiki/Potentially_visible_set),
https://en.wikipedia.org/wiki/Binary_space_partitioning

![](/images/the-principles-of-modern-game-ai/3/18-spatial-tree.jpg)

Как уже было сказано, не существует структуры для хранения пространственных
данных или алгоритма, которые были бы универсальными или подходили для всех
случаев. Чаще всего за базу берется какая-то уже существующая структура или
алгоритм, которые затем итеративно улучшаются, чтобы лучше решать какую-то
конкретную задачу - исходная структура данных может не подходить по
производительности, по степени покрытия пространства и так далее. В зависимости
от задачи для улучшения базы можно менять количество нодов, какие-либо их
характеристики, группировать и так далее.

Примером может служить задача вокселизации пространства. Сырые данные об
уровне, пришедшие от дизайнера уровней, сперва покрываются неприрывной сеткой,
а затем специальный алгоритм разбивает их на минимальное количество вокселей.

![](/images/the-principles-of-modern-game-ai/3/19-voxelization.jpg)

Другим примером может являться задача по объединению локаций на некотором
уровне в групные кластеры с целью использовать эти кластеры как опорные точки
для для раздачи команд. Здесь происходит постепенная кластеризация близлежайших
локаций, пока не будет достигнут некий предел.

![](/images/the-principles-of-modern-game-ai/3/20-clusterization.jpg)
