---
title: Принципы современного игрового ИИ. Второй урок
---

В данном уроке происходит обзор способа ручного добавления игрового контента,
управления им с целью ускорения и упращения разработки, а также небольшой обзор
алгебраических функций, которые можно использовать для автоматической генерации
контента.

## Авторинг

На практике существует множество способов создания игрового контента, но в
данном уроке будер рассмотрен подход с ручным созданием цифрового контента,
который и называется "авторинг". Казалось бы, какое отношение создание контента
имеет к искуственному интеллекту? Как будет рассмотрено, у авторинга есть
весомые приемущества по сравнению с другими подходами,
как с точки зрения бизнеса, так и с технологической точки зрения - главным
образом потому, что это наиболее простой способ добавления необходимого
контента в игру.

![](/images/the-principles-of-modern-game-ai/2/1-content-generation.jpg)

Итак, можно выделить семь основных причин, по которым авторинг имеет широкое
применение:

1. Ручное создание контента приводит к более глубогкому пониманию предметной
   области, а также к появлению более-менее формального определения или
   спецификации, что может поспособствовать автоматизации процесса генерации
   контента в будущем; авторинг можно использовать как базу, от которой потом
   отталкиваться

2. Авторинг провоцирует создание пайплайнов для загрузки контента с диска в
   движок, конвертацию их в удобоваримый формат и так далее; с самого начала
   разработки данная подсистема естественным образом будет хорошо
   оттестирована, а в последующем ничего не мешает просто заменить ручной
   контент на автоматически генерируемый

3. С точки зрения методологии данный подход позволяет получить рабочий прототип
   как можно раньше, постепенно его дорабатывая, что скажется на процессе
   разработки только положительным образом

4. Авторинг способствует контролю за сложностью, потому как вручную созданный
   цифровой контент лежит на диске и работает весьма независимо друг от друга;
   контент легче создать руками, чем написать код для его создания; меньше кода
   - меньше сложности в игровом движке

5. Если рассмотреть вопрос менеджмента, то авторинг удобней и дешевле, потому
   как позволяет распределять ответственность:
   проще нанять аниматоров и дизайнеров для создания ручного контента, чем
   программиста с необходимым уровнем навыков, который бы писал код для
   создания контента

6. Авторинг лучше масштабируется горизонтально - например, можно усилить работу
   над созданием контента ближе к релизу, наняв больше людей, в то время как на
   ранних этапах разработки достаточно небольшого количества контента;
   генерация контента с помощью кода чревата тем, что многие возможности могут
   не быть учтены на ранних этапах, и написанный для генерации движок может
   просто не позволить иметь те или иные возможность; может понадобиться его
   рефакторинг, etc

7. Наконец, ручное создание контента предполагает более высокое его качества;
   контент, сгенерированный с помощью алгоритмом, имеет свойство быть среднего
   качества, хотя его вариаций может быть существенно больше


Одной из главных проблем является поиск компромисса между качеством контента и
его количеством. Создание большого количества качественного контента требует
огромного количества ресурсов; с другой стороны, простое копирование контента
будет нарушать атмосферу игры - пользователю может не понравиться, например,
если он будет увидит ланшафт, состоящий из абсолютно идентичных гор.

Одним из способов достижения компромисса, помимо приемуществ с точки зрения
архитектуры, является использование модульного подхода. При этом подходе
целостная сущность дробиться на несколько частей, и затем требуется создать
несколько вариаций каждой из этих частей. Теперь, создание нового варианта
контента можно возложить на алгоритм. Таким образом, мы получаем комбинаторное
увеличение количества вариантов контента, и, вероятно, не сильно потеряем в
качестве.

![](/images/the-principles-of-modern-game-ai/2/2-modularity.jpg)

Но тут есть несколько нюансов, о которых необходимо помнить. В
некоторых случаях одни вариации могут зависеть от других - например, в случае,
когда некоторая фраза может быть произнесена только в след за определенной
предыдущей. Эти зависимости могут быть как явными, так и скрытыми, и при фиксе
багов необходимо удостовериться, что баг пофикшен во всех возможных комбинациях
контента.

![](/images/the-principles-of-modern-game-ai/2/3-modules-dependencies.jpg)

Существует два основных подхода к тому, чтобы привнести модульность в
создаваемый вручную контент. Первый - это подход с созданием шаблонов, подход
"сверху - вниз". В уже имеющимся контенте некоторые места заменяются на
переменные, то есть контент становится шаблоном, а актуальные значения в него
добавляются по требованию. Например, в генераторе ланшафта могут быть объявлены
места для точек интереса, а непосредственно то, что там сгенерировать - дом,
озеро или пещеру - принимается решение на последующем этапе. Данный подход
хорошо тем, что с него просто начать, и в некоторых случаях результат может
быть весьма высококачественным; с другой стороны, количество вариаций
ограничено вручную, и это вариации могут казаться весьма монотонными.

Другой подход, "снизу - вверх" - блочный подход. Основная идея - начать с
простых блоков и затем комбинировать из них более сложные. Данный подход не
страдает от малого объема вариаций и для некоторых случаев подходит просто
идеально, но зачастую не все комбинации имеют смысл, могут смотреться нелепо,
то есть качество хромает.

Ничто не мешает использовать при этом гибридный подход, создавая своеобразное
дерево шаблонов, при котором контент, сгенерированный из блоков, может
использоваться в качестве значения в заранее определенном шаблоне и при этом, с другой
стороны, каждый из блоков может создаваться по определенному шаблону.

![](/images/the-principles-of-modern-game-ai/2/4-templates-blocks-tree.jpg)

В некоторых случаях, если этих описанных подходов недостаточно, можно придумать
и другие подходы - например, с некой хитроумной системой оценки качества
контента, требующей перегенерации, пока результат не будет удовлетворять
определенным критериям.

## Data-driven движки

Для того, чтобы сделать процесс создания цифрового контента более удобным, а,
следовательно, и быстрым, необходима соответствующая поддержка со стороны
движка. Существует несколько хороших практик и рекомендаций, как организовать
движка на уровне файлов для упрощения процесса авторинга.

Во-первых, необходимо выработать соглашения об именовании файлов и строго его
придерживаться. Например, всегда использовать одно и то же разрешение для
определенного типа файлов, а имена файлов задавать, используя определенный
шаблон. Это упростит поиск файлов, так как большинство средств поиска
ориентированы в первую очередь именно на имена файлов.

Во-вторых, необходимо стремиться к тому, чтобы информация в файлах хранилась
приемущественно в текстовом виде, в формате, легко читаемом и редактируемом
человеком. Главное приемущество такого подхода - это поддержка со стороны
бесчисленного количества уже существующих утилит, редакторов, валидаторов, чего
сложно добиться с бинарными файлами. Можно посмотреть в сторону JSON, INI и
лисповских S-Expr.

![](/images/the-principles-of-modern-game-ai/2/5-file-content.jpg)

В-третьих, помимо именования файлов, необходимо подумать и о иерархии
директорий - не будет же все лежать в одной! Каких-то особых рекомендаций тут
нет, кто-то группирует по типу файлов, кто-то - по подсистемам, к которым файлы
относятся. Просто нужно выбрать наиболее подходящий для себя вариант.

В-четвертых, имеет смысл каждую сущность, описанную в том или ином файле,
снабдить уникальным идентификатором. Это поможет в случаях, когда имеются
какие-либо ссылки из одного файла в другой. Использовать в качестве ссылки имя
файла можно, но это не очень надежно, так как довольно часто файлы могут
перемещаться с места на место, и это потребует поддержания ссылочной
целостности. В качестве варианта можно рассмотреть UUID.

В-пятых, необходимо озадачиться вопросами контроля версий. Использование VCS
подразумевается как само собой разумеещееся, потому в этом пункте речь идет в
первую очередь об версиях форматов файлов. Движок может поддерживать несколько
форматов одного и того же типа файлов, и поэтому указание номера версии в явном
виде в начале файла, например, может весьма ускорить процесс отладки в случае
возникновения проблем; о неподдерживаемых версиях файлов движок может сообщать
сразу же, при загрузке, а не в рантайме.

Загрузка игрового движка может занимать некоторое время. С целью уменьшить
время ожидания на перезапуск игры после модификации исходников must-have должна
быть поддержка движком горячей перезагрузки ресурсов, в том числе скриптов. Это
может быть реализовано как с помощью простого сочетания клавиш, так и с помощью
более хитроумного подхода с мониторингом файловой системы. Это настолько
полезный с точки зрения экономии времени подход, что некоторые движки даже
предоставляют возможность перекомпилировать исходный код и подгружать результат
компиляции на лету.

![](/images/the-principles-of-modern-game-ai/2/6-hot-reload.jpg)

Зачастую  используется  разделения  классов  неправильно  поведения  на  ошибки
и  предупреждения  (warning),  которые  просто  печатаются  куда-либо.  Хорошей
практикой является  сведение предупреждений  к ошибкам, что  способствует тому,
чтобы их  не просто игнорировали,  как зачастую  бывает - данные  либо валидны,
либо нет. С другой стороны, просто прерывать программу в случае ошибки чревато
потерями времени, и чем больше команда, тем существеннее эти потери.
Альтернативой здесь может быть graceful degradation до состояния, в котором
можно продолжать работу.

На период разработки полезным может быть использовать очевидные и заметные
плейсхолдеры для отсутсвующего контента или каких-то особенностей геймплей,
которые необходимо трактовать особым образом. Например, использовать яркие
текстуры для объектов, для которых финальные текстуры еще не готовы. Это
не позволит случайно пропустить их перед релизом, а тестировщикам - понять, что
такое поведение ожидаемо, а не является багом.

![](/images/the-principles-of-modern-game-ai/2/7-debug-markers.jpg)

При внедрении новых фич хорошей практикой считается не включение их
по-умолчанию, а предоставление флагов конфигурации для их активации и
деактивации. Это позволит тестировать то, как интегрируются те или иные фичи, а
также, не останавливая работу других членов команды, если у них возникли
проблемы. Также не рекомендуется одномоментно удалять фичи - вместо этого,
лучше ввести некую политику устаревания, сообщая об этом с просьбой выключить
ее, используя соответствующий механизм. Особенно полезным является возможность
одновременного использования нескольких версий одной фичи одновременно с целью
поиска визуальных различий.

Несмотря на удобство текстового представления исходного контента, для игрового
движка может быть удобней и быстрее работать с бинарными файлами - просто
прочесть файл и положить его в память без дополнительных манипуляций.
Соответственно, нам необходим этап конвертации - компиляции - исходных данных в
удобную для движка форму, которая происходит с помощью каких-то утилит. Дабы
все еще иметь возможность горячей загрузки контента, нам необходима возможность
иметь эти тулзы в рантайме - с кэшированием скомпилированных файлов или без.

В случае, если процесс компиляции дорогостоящ, можно рассмотреть подход с
центральным хранилищем скомпилированных ассетов, доступных для всех членов
команды по уникальному идентификатору ассета - например, по хэшу.

## Алгебра для генерации контента

Алгебра - это наука об математических символах и правилах манипуляции этими
символами. Основными элементами являются:

- скаляры, или переменные, обычно представляемые прописными латинскими буквами (x, y, z)
- параметры, представляемые прописными греческими буквами (α, β, γ), своего
  рода плейсхолдеры для константных щзначений
- веткоры, обозначаемые заглавными латинскими буквами (V, T, M, G),
  представляющие собой массивы или даже матрицы значений
- операторы, которые обозначают различные комбинации предасвленных выше
  символов (Σ - сумма, Π - произведение, Δ - разность и т. п.)

Для целей генерации контента с помощью алгебры используются функции. Функции -
это описание отношений между входными параметрами и их результатом.
Функциональное программирование является естественной связью между
математическими функциями и их использовании с помощью компьютера. Нас главным
образом интересуют [непрерывные функции][ссыль], то есть функции без "скачков".
Их можно использовать в различных областях - генерации звуковых сигналов,
модификаторов движений и анимации, факторами, влияющими на принятие решений,
для генерации текстур и ландшафтов и так далее. В функиях нас главным образом
будет интересовать их очертания - зная, как функция отвечает на изменения
аргумента, мы сможем понять, в каких случаях лучше применить одну, а в каких -
другую. Существует множество типов функций - помимо простых и примитивных,
таких как identity и линейная функции, существуют квадратичные и кубические
функции, функции инверсии, экпоненциальные, логарифмические,
тригонометрические (sin, cos) функции, и, часто имеющие применение в машинном обучении, сигмоида и
softplus.

Помимо прочего, мы можем комбинировать функции друг с другом, используя
привычные математические операторы сложения, вычитания, умножения и деления,
создавая функцию с новыми свойствами и графиком, который
более применим в какой-то задаче.

![](/images/the-principles-of-modern-game-ai/2/8-functions-combining.jpg)

Новым направлением в генерации контента (в том числе компьютерной графики)
является использование distance fields. При использовании этого подхода вместо
расположения внешнего объекта, например игровой модели, состоящей из
полигонов, используется функциональный подход, и каждая точка нужной модели
вычисляется на основе входной точки и какой-то сложной формулы. Дублирование и вращение данных
объектов выполняется определенными преобразованиями над входным вектором точек.
Такой подход можно применять для генерации ландшафта a-la Minecraft, например,
начав с простого шара и затем итеративно добавлять все новые и новые функции,
стремясь получить требуемый результат.

Незаменимым классом функций для генерация контента являются функции генерации
шума (noise). Данные функции используются, чтобы добавить некий эффект
случайности и уникальность к автоматически сгенерированному контенту. Типичный
способ создать шум - это начать с синусоиды и добавлять новые слои путем
применения каких-то других функций с помощью различных операторов. И, хотя
некий паттерн в результирующей функции можно увидеть, тот или иной сегмент ее
графика вполне себе обладает уникальностью и может быть использован для
практических целей - модификации текстуры, генерации ланшафта и так далее.

![](/images/the-principles-of-modern-game-ai/2/9-noise-function.jpg)

Самым популярным примером является шум Перлина (ССЫЛЬ).


**Написать о том, что последняя часть выбивается из темы?**
