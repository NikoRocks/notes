---
title: Принципы современного игрового ИИ. Первый урок
---

## 1.1 Архитектура агента

Классическая схема вычислительного процесса интерактивного агента, пришедшая из
области робототехники, это связка "ощущаю - думаю - действую".

На первом этапе агент собирает, как-то преобразует и запоминает
ту или иную информацию из внешнего мира с помощью
специализированных сенсоров. На этапе обдумывания происходит анализ
накопленной информации с целью определить, какие действия необходимо совершить
для достижения поставленных целей. И, собственно, после этого происходит черед
совершать дейтсвия. Тем не менее, каждый из этих шагов может быть весьма
сложен: при принятии того или иного решения может потребоваться дополнительная
информация из окружающего мира, и необходимо будет сделать дополнительный
запрос к сенсорам; при планировании может использоваться механизм
предугадывания результата действий, то есть может быть задействована
подсистема, отвечающая за исполнение действий. Таким образом, каждый из этапов
не быть выделен явно и размазан по коду.

Альтернативная архитектура заключается в выделении функциональных слоев, каждый
из которых отвечает за тот или иной аспект работы движка - например, физику,
анимацию, поведение и так далее. Поток управления в таком случая перестает быть
горизонтальным и становится вертикальным: каждый слой строится поверх другого.
Внутри каждого из слоев, впрочем, логика поведения остается схожей - мы
анализируем внешние данные для генерации тех или иных действий. С другой
стороны, не каждый из слоев непосредственно сам меняет состояние ИА - для этого
может потребоваться использовать фнукционал других слоев. Например, слой
навигации после генерации оптимального маршрута может обратиться к слоям физика
и анимации.

![](/images/the-principles-of-modern-game-ai/1/1-layers.jpg)

Такая
архитектура дает следующие приемущества:

- очевидная структура агента в коде
- упрощение внутренних кросс-зависимостей в коде
- и, как следствие, упрощение поддержки, в том числе с целью удаления, если
  в следующей игре, использующей тот же движок, исчезнет необходимость
  поддерживать тот или иной аспект работы движка

С целью повысить эффективность вычислений и модульность кода, может иметь смысл
выделить код, отвечающий за взаимодействие с игровым движком, в отдельные
системы: систему физики, анимации и т. д., предоставляющих высокоуровневый
интерфейс для соответствующих компонентов;
в них же могут шарится общая для всех агентов информация и алгоритмы.

## 1.2 Поток информации

Можно выделить несколько фаз при работе интерактивного агента. Первая и
последняя фаза обязательно, но остальные могут быть присущи не всем агентам -
когда, например, не требуется чрезвычайно сложное, человекоподбное поведение.

*Извлечение* информации из игрового мира и преобразование её в структуры, более
подходящие для обработки внутри ИА.

*Обработка* извлеченной информации: преобразование и объединение её в более сложные
структуры для последующих фаз работы.

*Обдумывание* имеющейся информации с целью дополнения общей картины фактами,
которые можно построить на основе извлеченной информации, но которые отсутсвуют
а ней напрямую - например, предположение о текущем положении игрока.

*Принятие решения*, исходя из целей существования ИА и результатов работы
предыдущей фазы. На этом этапе могут использоваться алгоритмы построения
оптимального пути, предположения о том, какие реакции последуют в ответ на те
или иные действия ИА и так далее.

*Генерация* структур данных, пригодных для конвертации в примитивные операции
игрового движка, на основе принятых решений.

*Конвертация* принятых решений обратно в низкоуровневые понятия игрового движка
- перемещение в пространстве, отыгрывание анимаций и так далее.

Сущесвует два подхода к тому, как будет оповещаться интерактивный агент об
изменениях окружающего его мира. Первый подход - *поллинг*, когда агент сам, на
периодической основе, опрашивает мир об изменениях. Такой подход хорошо
применять в случае, если мир обновляется довольно части - иначе оверхэд на
опрос информации будет лишним. Альтернатива ему, в случае, когда изменения
происходят редко - *пушинг*, когда ИА
подписывается не накоторые события игрового мира, и уведомляется о них при их
наступлении.

![](/images/the-principles-of-modern-game-ai/1/2-polling.jpg)

Разумеется, можно применять гибридный вариант, когда некоторые
данные окружающего мира изменяются часто и агент обновляет их самостоятельно
путем опроса, а для других, менее часто обновляемых данных, используется
система подписки на изменения.

## 1.3 Поток управления

Поток управления в интерактивном агенте непосредственно управляет тем, как
информация проходит по различным фазам. ???

Типичная задача такова, что, для каждого ИА, у нас есть несколько задач, которые нам необходимо
обработать, причем некоторые из задач зависят одна от другой. С целью
оптимизации данные задачи имеет смысл объединить в пакеты по принципу
независимости друг от друга, то есть в рамках одного пакета может исполняться
параллельно несколько задач.



Существует два подхода к решению этой проблемы. Первый, *обновление сущностей*,
фокусируется на обновлении отдельных сущностей последовательно. На каждом витке
игрового цикла происходит итерация по всем сущностям, которые необходимо
обновить, и для каждой выполняются необходимые ей действия. Данный подход прост
в исполнении и понимании процесса исполнения и довольно часто применяется. С
другой стороны, он не самый оптимальный с точки зрения производительности и
может быть чреват ошибками вследствии серьезной зависимости от порядка
исполнения задач.

Второй подход, *обновление слоев*, фокусируется на последовательной обработке
системных слоев, таких как слой анимации, слой физики и т. д., для каждой из сущностей.
То есть перед началом этапа обработки очередного слоя, обработка в рамках
предыдущего для каждой сущности уже завершилась. Порой обработку каждого слоя
даже разделяют на несолько шагов: предобработка, в которой происходит
подготовка к непосредственной обработке, то есть второму шагу, и, наконец,
постобработка, в который исполняются некоторые завершающие действия.
Плюсы такого подхода - самое
оптимальное использование доступных ресурсов и меньшая вероятность совершить
простые ошибки, но при этом его реализация требует много времени и опыта, а для
некоторых случаев такой подход может даже мешать.

![](/images/the-principles-of-modern-game-ai/1/3-updating-layers.jpg)

Итак, чаще всего имеет смысл начинать с подхода с обновлением сущностей и
дальше, по мере необходимости, вводить подход с обновлением слоев в те или иные
слои.

Для последовательной обработки сущностей существует несколько стратегий:

Визуально привлекательный => отзывчиввый.

Виток - фрейм?

1. *Брутфорс*. Тут все просто - каждый виток цикла происходит обработка всех сущностей.
   Этот подход простой, ясный и при этом визуально более привлекательный - на
   каждом этапе мы уверены, что все сущности обновили свое представление. С
   другой стороны, его можно считать медленным и тратящим ресурсы - не каждому
   агенту может требоваться обновление в каждом витке.

2. *На основе событий*. Те или иные сущности проходят процесс обновления в
   данном витке только в случае, если произошло определенное событие. Таким
   образом, за счет того что на каждом витке обрабатываются только те сущности,
   что требуют этого, данный подход является довольно быстрым, все еще
   визуально привлекательным и при этом - элегантным. Но он чреват
   вычислительными спайками - в случае, когда на очередном витке произошло
   слишком много событий, требующих обновления множества сущностей, что может
   заставить просесть производительность.

3. *Раунд робин* (ссыль). При этом подходе все сущности делятся на несколько
   групп, и на каждом витке происходит обработка сущностей из той или иной
   группы, по очереди. Данный подход менее отзывчивый, но при этом достаточно
   предсказуемый.

4. *На основе очередей*. Данный подход комбинирует два предыдущих с целью
   оставаться достаточно отзывчивым и при этом избежать спайков вычисления.
   События, говорящие о том, что ту или иную сущность нужно обновить, ставятся
   в очередь и откладываются до следующего витка при достижении определенного
   лимита ресурсов. Данный подход менее предсказуемый и более сложный в
   реализации.

5. *Приоритизация*, который может комбинироваться с другими стратегиями и
   больше подходит для игр с большим открытым миром. В данном подходе сущности,
   находящиеся неподалеку от игрока, имеют больший приоритет при обновлении, и
   по мере удаление от игрока сущности теряют приоритет и их обновление может
   откладываться или становиться в очередь. Самая сложная в реализации
   стратегия.


